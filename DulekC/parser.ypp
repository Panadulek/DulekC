%{
#include <memory>
#include <iostream>
#include <string>
#include "AstTree.h"
#include "DuObject.h"
#include "Type.h"
#include "Variable.h"
#include "Value.h"
#include "TypeContainer.h"
#include <cstdint>
#include <vector>
#include "Statement.h"
#include "FlagsSettings.h"
 extern char* yytext;
 int __cdecl yylex(void);
void yyerror(const char *s) { std::cerr  << s << "  :   " << '"' << yytext << '"' << std::endl; }

std::vector<Type*> yys_types;
std::vector<Identifier> yys_ids;


%}
%code requires {

    #include "Type.h"
    #include "Variable.h"
    #include "DuObject.h"
    #include <memory>
    #include <string>
    #include <cstdint>
    #include <vector>
    #include "Statement.h"
    // Inne wymagane nag³ówki
}
%union {
    char* str;  
    uint64_t num; 
    Variable* pvariable;
    Type* ptype;
    NumericValue* pnumvalue;
    ObjectInByte bytetype;
    Identifier* pidentifier;
    Statement* pstatement;
}

%token ARROW LBRACE RBRACE COMMA SEMICOLON LBUCKLE RBUCKLE INIT_TYPE FUNCTION_KEYWORD ASSIGMENT
%token <bytetype> I8 U8 I16 U16 I32 U32 I64 U64
%token <str> IDENTIFIER
%token <num> NUMBER


%start program

%type<bytetype> byte_type
%type<bytetype> ubyte_type
%type<ptype> type
%type<pvariable>variable_declaration
%type<pnumvalue> variable_numeric_init
%type<pidentifier> argument
%type<pstatement>  variable_assigment
%%

program
    : /* pusty */
    | program statement
    ;

statement
    : statement
    | variable_declaration
    | function_declaration
    | function_body_begin
    | function_body_end
    | variable_assigment
    ;



function_declaration:
    FUNCTION_KEYWORD IDENTIFIER LBRACE argument_list RBRACE ARROW type LBRACE type_list RBRACE 
    {
        if(!CompilerParserFlags::instance().enterFunction())
        {
            throw std::runtime_error("FN_IN_FN");
        }
        if(yys_ids.size() != yys_types.size())
        {
            throw std::runtime_error("type_size_counter_not_eq");
        }
        Function* fn = new Function(Identifier($2), $7);
        delete [] $2;
        AstTree::instance().beginScope(fn);
        for(auto i = 0; i < yys_types.size(); i++ )
        {
            fn->addArgs(new Variable(yys_ids[i], yys_types[i], new NumericValue(), AstTree::instance().inGlobal()));
        }

       
    }

    function_body_begin:
        LBUCKLE 
        {
            if(!CompilerParserFlags::instance().isInFunction())
                throw std::runtime_error("NO_IN_FN");

        }

    function_body_end:
        RBUCKLE 
        {
            if(!CompilerParserFlags::instance().isInFunction())
                throw std::runtime_error("NO_IN_FN");
            AstTree::instance().endScope();
            CompilerParserFlags::instance().exitFunction();
        }
variable_declaration
    : 
    IDENTIFIER ARROW type INIT_TYPE variable_numeric_init SEMICOLON
    {
        Identifier id($1);
        $$ = new Variable(id, $3, $5, AstTree::instance().inGlobal());
        AstTree::instance().addObject($$);
        delete [] $1;
    }
    | IDENTIFIER ARROW type SEMICOLON
    {
        Identifier id($1);
        $$ = new Variable(id, $3, new NumericValue(), AstTree::instance().inGlobal());
        AstTree::instance().addObject($$);
        delete [] $1;
    }
    ;

    variable_numeric_init 
        :
        NUMBER
        {
            $$ = new NumericValue($1)
        }


    type
    : byte_type
    {
       Identifier id = SimpleNumericType::generateId($1, true) ;
       TypeContainer::instance().insert<SimpleNumericType>(id, id, $1, true);
       $$ = TypeContainer::instance().getType(id);
     
    }
    |
     ubyte_type
    {
        Identifier id = SimpleNumericType::generateId($1, true) ;
        TypeContainer::instance().insert<SimpleNumericType>(id, id, $1, false);
        $$ = TypeContainer::instance().getType(id);
    }
    ;

  byte_type:
  I8 
  {
   $$ = $1;
  }
  | 
  I16
  {
    $$ = $1;
  }
  |
  I32 
  {
    $$ = $1;
  }
  | 
  I64
  {
    $$ = $1;
  }

  ubyte_type:
  U8 
  {
    $$ = $1;
  }
  | 
  U16
  {
    $$ = $1;
  }
  |
  U32 
  {
    $$ = $1;
  }
  | 
  U64
  {
   $$ = $1;
  }


  argument_list:
  | argument {
        yys_ids.push_back(*$1);
        delete $1;
    }
  | argument_list COMMA argument { 
  
    yys_ids.push_back(*$3);
    delete $3;
  }
  ;

  argument:
    IDENTIFIER
    {
        $$ = new Identifier($1);
        delete [] $1;
    }
  ;

  type_list:
  | type 
  {
    yys_types.push_back($1);
  }
  | type_list COMMA type
  {
    yys_types.push_back($3);
  }
  ;

  variable_assigment:
    argument ASSIGMENT argument SEMICOLON
    {
        if(!CompilerParserFlags::instance().isInFunction())
            throw std::runtime_error("NO_IN_FN");
        $$ = new AssigmentStatement(*$1, *$3);
        AstTree::instance().addObject($$);
    }

%%

