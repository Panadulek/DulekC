%{
#include <memory>
#include <iostream>
#include <string>
#include "AstTree.h"
#include "DuObject.h"
#include "Type.h"
#include "Variable.h"
#include "Value.h"
#include "TypeContainer.h"
#include <cstdint>
#include <vector>
#include "Statement.h"
#include "SystemFunctions.h"
#include "Expression.h"
#include "ContextAnalyzer.h"
#include "MessageEngine.h"
#include "LexerContext.h"
#include "Ifscope.h"
extern std::unique_ptr<MessageEngine> s_messageEngine;
extern LexerContext* s_lc;
 extern char* yytext;
 int __cdecl yylex(void);

void yyerror(const char *s) 
{ 
    s_messageEngine->printError(MessageEngine::Code::ERROR_TOKEN, yytext);
}

std::vector<Type*> yys_types;
std::vector<Identifier> yys_ids;
extern int lex(void);
#define yylex lex

%}



%code requires {

    #include "Type.h"
    #include "Variable.h"
    #include "DuObject.h"
    #include <memory>
    #include <string>
    #include <cstdint>
    #include <vector>
    #include "Statement.h"
    #include "Expression.h"
    // Inne wymagane nag³ówki
}
%union {
    char* str;  
    uint64_t num; 
    Variable* pvariable;
    Type* ptype;
    NumericValue* pnumvalue;
    ObjectInByte bytetype;
    Identifier* pidentifier;
    Statement* pstatement;
    Value* pval;
    Expression* pexpr;
}

%token ARROW LBRACE RBRACE COMMA SEMICOLON LBUCKLE RBUCKLE INIT_TYPE ASSIGMENT PLUS MINUS MULTIPLICATION DIV COMMENT
%token FUNCTION_KEYWORD RETURN_KEYWORD IF_KEYWORD
%token SYS_DISPLAY
%token <bytetype> I8 U8 I16 U16 I32 U32 I64 U64
%token <str> IDENTIFIER
%token <num> NUMBER



%start program

%type<bytetype> byte_type
%type<bytetype> ubyte_type
%type<ptype> type
%type<pvariable>variable_declaration
%type<pnumvalue> variable_numeric_init
%type<pidentifier> argument
%type<pstatement>  variable_assigment
%type<pval> just_value_init
%type<pexpr> factor
%type<pexpr> term
%type<pexpr> expression
%%

program
    : /* pusty */
    | program statement
    ;

statement
    : variable_declaration
    | function_declaration
    | variable_assigment
    | ignored_rules
    | if_block
    ;



function_declaration:
    FUNCTION_KEYWORD IDENTIFIER LBRACE argument_list RBRACE ARROW type LBRACE type_list RBRACE 
    {
        if(!s_lc->isInGlobalContext())
        {
            s_messageEngine->printError(MessageEngine::Code::FunctionInsideScope, nullptr);
            exit(static_cast<uint32_t>(MessageEngine::Code::FunctionInsideScope));
        }
        if(yys_ids.size() != yys_types.size())
        {
            throw std::runtime_error("type_size_counter_not_eq");
        }

        const bool isProcedure = !$7;
        Function* fn = new Function(Identifier($2), $7, std::move(yys_ids), std::move(yys_types), false, isProcedure);
        AstTree::instance().beginScope(fn);
        s_lc->setNeedOpenBuckle(true);
        delete [] $2;
    }

if_block:
    IF_KEYWORD LBRACE expression RBRACE
    {
        if(s_lc->isInGlobalContext())
        {
            s_messageEngine->printError(MessageEngine::Code::FunctionInsideScope, nullptr);
            exit(static_cast<uint32_t>(MessageEngine::Code::FunctionInsideScope));
        }
        auto& tree = AstTree::instance();
        IfScope* isc = new IfScope($3);
        tree.addObject(isc);
        tree.beginScope(isc);
        s_lc->setNeedOpenBuckle(true);
    }
    ;
variable_declaration
    : 
    IDENTIFIER ARROW type INIT_TYPE just_value_init SEMICOLON
    {
        Identifier id($1);
        $$ = new Variable(id, $3, $5, AstTree::instance().inGlobal());
        AstTree::instance().addObject($$);
        delete [] $1;
    }
    | IDENTIFIER ARROW type SEMICOLON
    {
        Identifier id($1);
        $$ = new Variable(id, $3, new NumericValue(), AstTree::instance().inGlobal());
        AstTree::instance().addObject($$);
        delete [] $1;
    }
    ;
    just_value_init
    :
    variable_numeric_init
    {
        $$ = $1;
    }
    ;
    variable_numeric_init 
        :
        NUMBER
        {
            $$ = new NumericValue($1)
        }


    type
    : 
    {$$ = nullptr;}
    |
    byte_type
    {
       Identifier id = SimpleNumericType::generateId($1, true) ;
       TypeContainer::instance().insert<SimpleNumericType>(id, id, $1, true);
       $$ = TypeContainer::instance().getType(id);
     
    }
    |
     ubyte_type
    {
        Identifier id = SimpleNumericType::generateId($1, true) ;
        TypeContainer::instance().insert<SimpleNumericType>(id, id, $1, false);
        $$ = TypeContainer::instance().getType(id);
    }
    ;

  byte_type:
  I8 
  {
   $$ = $1;
  }
  | 
  I16
  {
    $$ = $1;
  }
  |
  I32 
  {
    $$ = $1;
  }
  | 
  I64
  {
    $$ = $1;
  }

  ubyte_type:
  U8 
  {
    $$ = $1;
  }
  | 
  U16
  {
    $$ = $1;
  }
  |
  U32 
  {
    $$ = $1;
  }
  | 
  U64
  {
   $$ = $1;
  }

  argument_list:
  | argument {
        yys_ids.push_back(*$1);
        delete $1;
    }
  | NUMBER
  {
        yys_ids.push_back(Identifier(std::to_string($1)));
  }
  | argument_list COMMA argument { 
  
    yys_ids.push_back(*$3);
    delete $3;
  }
 | argument_list COMMA NUMBER { 
  
    yys_ids.push_back(Identifier(std::to_string($3)));
  }
  ;

  argument:
    IDENTIFIER
    {
        $$ = new Identifier($1);
        delete [] $1;
    }
  ;

  type_list:
  | type 
  {
    if($1)
        yys_types.push_back($1);
  }
  | type_list COMMA type
  {
    if($3)
        yys_types.push_back($3);
  }
  ;



  variable_assigment:
    argument ASSIGMENT argument SEMICOLON
    {
        if(s_lc->isInGlobalContext())
        {
            s_messageEngine->printError(MessageEngine::Code::ExecuteGlobalExpression, nullptr);
            exit(static_cast<uint32_t>(MessageEngine::Code::ExecuteGlobalExpression));
        }
        auto& tree = AstTree::instance();
		auto l = dynamic_cast<Variable*>(tree.findObject(*$1));
		auto r = dynamic_cast<Variable*>(tree.findObject(*$3));
        $$ = new AssigmentStatement(l, r);
        tree.addObject($$);
        delete $1;
        delete $3;
    }
    |
    argument ASSIGMENT just_value_init  SEMICOLON
    {
        if(s_lc->isInGlobalContext())
        {
            s_messageEngine->printError(MessageEngine::Code::ExecuteGlobalExpression, nullptr);
            exit(static_cast<uint32_t>(MessageEngine::Code::ExecuteGlobalExpression));
        }
        auto& tree = AstTree::instance();
        auto l = dynamic_cast<Variable*>(tree.findObject(*$1));
        Variable* r = new Variable(Identifier(""), l->getType(), $3, tree.inGlobal());
        $$ = new AssigmentStatement(l, r);
        tree.addObject($$);
        delete $1;
    }
    |
    argument ASSIGMENT  expression SEMICOLON
    {
        if(s_lc->isInGlobalContext())
        {
            s_messageEngine->printError(MessageEngine::Code::ExecuteGlobalExpression, nullptr);
            exit(static_cast<uint32_t>(MessageEngine::Code::ExecuteGlobalExpression));
        }
        auto& tree = AstTree::instance();
        auto l = dynamic_cast<Variable*>(tree.findObject(*$1));
        $$ = new AssigmentStatement(l, $3);
        tree.addObject($$);
        delete $1;

    }
    |
    RETURN_KEYWORD argument SEMICOLON
    {
        if(s_lc->isInGlobalContext())
        {
            s_messageEngine->printError(MessageEngine::Code::ExecuteGlobalExpression, nullptr);
            exit(static_cast<uint32_t>(MessageEngine::Code::ExecuteGlobalExpression));
        }
        auto& tree = AstTree::instance();
        auto l = tree.findObject(*$2);
        auto s = tree.getCurrentScope();
        if( s->isFunction() )
        {
            $$ = new ReturnStatement(l, static_cast<Function*>(s)->getType());
            tree.addObject($$);
        }
        else if(s->isIfScope())
        {
        }
        else
        {
             throw std::runtime_error("NOT FUNCTION");
        }
        delete $2;
    }
    |
    SYS_DISPLAY LBRACE argument_list RBRACE SEMICOLON
    {
        if(s_lc->isInGlobalContext())
        {
            s_messageEngine->printError(MessageEngine::Code::ExecuteGlobalExpression, nullptr);
            exit(static_cast<uint32_t>(MessageEngine::Code::ExecuteGlobalExpression));
        }
        auto& tree = AstTree::instance();
        Identifier id(SystemFunctions::getSysFunctionName<SystemFunctions::SysFunctionID::DISPLAY>());
        Function* f = tree.findFunction(id);
        $$ = new CallFunction( new CallFunctionExpression(std::move(yys_ids), f) );
        tree.addObject($$);
    }
    |
    argument LBRACE argument_list RBRACE SEMICOLON
    {
        if(s_lc->isInGlobalContext())
        {
            s_messageEngine->printError(MessageEngine::Code::ExecuteGlobalExpression, nullptr);
            exit(static_cast<uint32_t>(MessageEngine::Code::ExecuteGlobalExpression));
        }
        auto& tree = AstTree::instance();
        Function* f = tree.findFunction(*$1);
        $$ = new CallFunction( new CallFunctionExpression(std::move(yys_ids), f) );
        tree.addObject($$);
        delete $1;
    }
    |

    ;




    expression
    : term { $$ = $1}
    | expression PLUS term
        { $$ = new MatematicalExpression(Identifier("+"), $1, $3);    }
    | expression MINUS term
        { $$ = new MatematicalExpression(Identifier("-"), $1, $3);    }

    ;

term
    : factor { $$ = $1 }
    | term MULTIPLICATION factor
    { 
        $$ = new MatematicalExpression(Identifier("*"), $1, $3);    
    }
    | term DIV factor
        { $$ = new MatematicalExpression(Identifier("/"), $1, $3);    }
    ;

factor
    : NUMBER
        {
           $$ = new BasicExpression(Identifier(std::to_string($1)));
        }
    | argument
        { 
            $$ = new BasicExpression(*$1);
            delete $1;
        }
    | LBRACE expression RBRACE
    {
            $$ = $2; 
    }
    | argument LBRACE argument_list RBRACE 
    {
        auto& tree = AstTree::instance();
        Function* f = tree.findFunction(*$1);
        $$ = new CallFunctionExpression(std::move(yys_ids), f);
        delete $1;
    }
    ;


    ignored_rules:
        LBUCKLE{}
        |
        RBUCKLE{}
        |
        COMMENT{}
%%

